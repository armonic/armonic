#!/usr/bin/python

import sys
import logging
import argparse
from uuid import uuid4

from sleekxmpp import ClientXMPP

from sleekxmpp.thirdparty import OrderedDict

import armonic.common
from armonic.serialize import Serialize
from armonic.client.smart import Provide, smart_call
from armonic.utils import OsTypeAll
from armonic.client.sock import ClientSocket

DONT_MANAGE = "None"
"""Describe the value passed to not manage a provide"""

class MyProvide(Provide):

    def do_lfm(self):
        self.lfm = lfm
        return False

    def do_post_specialize(self):
        self.suggested_host = ""
        # suggest the host of the parent require
        if self.requirer and self.requirer.host:
            self.suggested_host = self.requirer.host
        return self.is_external

    def on_post_specialize(self, host):
        self.host = str(host)
        if host in ("localhost", "127.1", "127.0.0.1"):
            self.lfm = lfm
        else:
            self.lfm = ClientSocket(host=host)

    def do_call(self):
        return False

    def do_manage(self):
        self.manage = True
        return False

    def do_specialize(self):
        return True

    def on_specialize(self, data):
        """At specialization step, we also want to stop the managmenet of this
        provide."""
        if data == DONT_MANAGE:
            self.manage = False

class Master(ClientXMPP):

    def __init__(self, jid, password, lfm):
        ClientXMPP.__init__(self, jid, password)
        self.add_event_handler("session_start", self.session_start)
        self.lfm = lfm
        self.smart = None

    def session_start(self, event):
        self.send_presence()
        self.get_roster()

        self['xep_0050'].add_command(node='provides',
                                     name='Get the list of provides',
                                     handler=self._handle_command_provides)
        self['xep_0050'].add_command(node='build',
                                     name='Build a provide',
                                     handler=self._handle_command_build)

    def _handle_command_provides(self, iq, session):
        print "_handle_command_provides"
        form = self['xep_0004'].makeForm('form', 'List of provides')
        form['instructions'] = 'Choose a xpath amongst them'
        form.add_reported("xpath")
        form.add_reported("tag")
        form.add_reported("label")
        form.add_reported("help")

        for provide in self.lfm.provide("//*"):
            tags = ""
            if provide['extra'].get('tags'):
                tags = ",".join(provide['extra']['tags'])

            form.add_item(OrderedDict({
                "xpath": provide['xpath'],
                "tag": tags,
                "label": provide['extra'].get('label', provide['name']),
                "help": provide['extra'].get('help', '')
            }))

        session['payload'] = form
        session['next'] = None  # self._handle_command_init_walk
        session['has_next'] = False
        session['id'] = str(uuid4())

        return session

    def _handle_command_build(self, iq, session):
        form = self['xep_0004'].makeForm('form', 'Specify a provide to build')
        form['instructions'] = 'specify'
        form.add_field(var="xpath")
        session['payload'] = form
        session['next'] = self._handle_command_init_build_next
        session['has_next'] = True
        session['id'] = str(uuid4())

        self.smart = None
        self.root_provide = None
        self.current_step = None

        return session

    def _handle_command_init_build_next(self, payload, session):
        if self.smart is None:
            print "Step: Create root_provide"
            xpath = payload['values']['xpath']
            self.root_provide = MyProvide(generic_xpath=xpath)
            self.smart = smart_call(self.root_provide)

        #if self.current_step == "manage":
        #    provide, step, args = self.smart.send(True)
        #
        if self.current_step == "specialize":
            provide, step, args = self.smart.send(payload['values']['xpath'])

        elif self.current_step == "post_specialize":
            provide, step, args = self.smart.send(payload['values']['host'])

        elif self.current_step == "multiplicity":
            provide, step, args = self.smart.send(int(payload['values']['multiplicity']))

        else:
            provide, step, args = self.smart.next()

        form = self['xep_0004'].makeForm('form', 'Build a provide')
        self.current_step = step

        print "Current step is now %s" % step

        form['instructions'] = step
        form.add_field(var="provide",
                       ftype="fixed",
                       value=provide.xpath or provide.generic_xpath,
                       label=provide.extra.get('label', provide.name))

        form.add_field(var="tree_id",
                       ftype="fixed",
                       value=str(provide.tree_id))

        if step == 'multiplicity':
            form.add_field(var="multiplicity",
                           ftype="input-single",
                           value="1")

        if step == 'specialize':
            field = form.add_field(var="specialize",
                                   ftype="list-single",
                                   desc="specialize the provide or disable it",
                                   options=[
                                       {"label": "Manual", "value": DONT_MANAGE}
                                   ])
            for provide_match in provide.matches():
                field.add_option(label=str(provide_match['extra'].get('label', provide_match['name'])),
                                 value=str(provide_match['xpath']))

        if step == 'post_specialize':
            provide_label = provide.extra.get('label', provide.xpath)
            label = provide_label[0].lower() + provide_label[1:]
            field = form.add_field(var="host",
                                   ftype="input-single",
                                   desc="on which host do you want to call the provide",
                                   label="Where do you want to %s ?" % label,
                                   value=provide.suggested_host)

        if step == 'validation':
            for variable in provide.variables():
                value = variable.value_get_one()
                field = form.add_field(var=str(variable.xpath),
                                       label=str(variable.name),
                                       ftype="list-multi",
                                       options=[
                                           {"label": "value", "value": str(value)},
                                           {"label": "resolved_by", "value": str(getattr(variable._resolved_by, "xpath", ""))},
                                           {"label": "suggested_by", "value": str(getattr(variable._suggested_by, "xpath", ""))},
                                           {"label": "set_by", "value": str(getattr(variable._set_by, "xpath", ""))}
                                       ],
                                       required=variable.required)
                for key, value in variable.extra.items():
                    field.add_option(label=str(key), value=str(value))

        session['payload'] = form
        session['next'] = self._handle_command_init_build_next
        session['has_next'] = True

        # If the root provide step is done, this is the last answer.
        if step == 'done' and provide == self.root_provide:
            session['next'] = None
            session['has_next'] = False

        return session


if __name__ == '__main__':
    parser = argparse.ArgumentParser(prog=sys.argv[0])
    parser.add_argument('--host',
                        type=str,
                        default="im.aeolus.org",
                        help="XMPP server host")
    parser.add_argument('--port',
                        default=5222, type=int,
                        help="XMPP server port (default '%(default)s')")
    parser.add_argument('--jid', '-j',
                        default='mss-master@im.aeolus.org', type=str,
                        help="Jid (default '%(default)s')")
    parser.add_argument('--password', '-p',
                        default='mss-master', type=str,
                        help="Password (default '%(default)s')")
    parser.add_argument('--input-event-file', '-i',
                        default='-', type=argparse.FileType('r', 0),
                        help="Input file where events are read")
    parser.add_argument('--lifecycle-dir', type=str, action='append',
                        help="A lifecycle directory")
    parser.add_argument('--no-default', action='store_true',
                        default=False, help="Don't load default lifecycles")
    args = parser.parse_args()


    if not args.no_default:
        armonic.common.load_default_lifecycles()

    if args.lifecycle_dir is not None:
        for l in args.lifecycle_dir:
            armonic.common.load_lifecycle(l)

    lfm = Serialize(os_type=OsTypeAll())

    logging.basicConfig(level=logging.DEBUG,
                        format='%(levelname)-8s %(message)s')

    xmpp = Master('%s/master' % args.jid, args.password, lfm=lfm)

    xmpp.register_plugin('xep_0030')  # Service Discovery
    xmpp.register_plugin('xep_0004')  # Data Forms
    xmpp.register_plugin('xep_0050')  # Adhoc Commands
    xmpp.register_plugin('xep_0199', {'keepalive': True, 'frequency': 15})

    xmpp.connect(address=(args.host, args.port))
    try:
        xmpp.process(block=True)
    except KeyboardInterrupt:
        pass
