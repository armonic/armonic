#!/usr/bin/python

import sys
import logging
import argparse
from uuid import uuid4
import json
import os.path

from sleekxmpp.thirdparty import OrderedDict

import armonic.common
from armonic.serialize import Serialize
from armonic.client.smart import Provide, smart_call, SmartException
from armonic.utils import OsTypeAll
import armonic.frontends.utils
from armonic.client.xmpp import XMPPAgentApi, XMPPClientBase


class MUCHandler(logging.Handler):

    def init_client(self, client):
        self.client = client

    def emit(self, record):
        if not self.client:
            return
        if self.client.muc_room and record:
            self.client.send_message(mto=self.client.muc_room,
                                     mbody="[%s] %s" % (str(record._ip), str(record.msg)),
                                     mtype='groupchat')
        return True


muc_handler = MUCHandler()
format = '%(ip)-15s %(message)s'
muc_handler.addFilter(logging.Filter('armonic'))
muc_handler.setFormatter(logging.Formatter(format))
agent_handler = logging.StreamHandler()
format = '%(ip)-15s %(levelname)-19s %(module)s %(message)s'
agent_handler.setFormatter(armonic.client.utils.ColoredFormatter(format))
xmpp_client = None


logger = logging.getLogger()
# To redirect master agent log to xmpp clients
# logger.addHandler(muc_handler)


class BuildProvide(Provide):

    def on_manage(self, data):
        # FIXME: Strophejs doesn't send a false value
        if data is None:
            self.manage = False
        else:
            self.manage = True

    def on_lfm(self, host):
        self.lfm_host = host
        self.lfm = XMPPAgentApi(xmpp_client, host)


class XMPPMaster(XMPPClientBase):

    def __init__(self, jid, password, plugins=[], muc_domain=None, lfm=None):
        XMPPClientBase.__init__(self, jid, password, plugins)

        self.lfm = lfm
        self.smart = None

        self.muc_nick = 'master'
        self.muc_domain = muc_domain
        self.muc_room = None

        muc_handler.init_client(self)

    def leave_muc_room(self):
        if self.muc_room:
            self['xep_0045'].leaveMUC(self.muc_room, self.muc_nick)
            self.muc_room = None

    def join_muc_room(self, session):
        self.muc_room = "%s@%s" % (session['id'], self.muc_domain)
        logger.info('Joining muc_room %s' % self.muc_room)
        self['xep_0045'].joinMUC(self.muc_room,
                                 self.muc_nick)

    def session_start(self, event):
        XMPPClientBase.session_start(self, event)

        self['xep_0050'].add_command(node='provides',
                                     name='Get the list of provides',
                                     handler=self._handle_command_provides)
        self['xep_0050'].add_command(node='build',
                                     name='Build a provide',
                                     handler=self._handle_command_build)

    def _handle_command_provides(self, iq, session):
        self.leave_muc_room()

        form = self['xep_0004'].makeForm('form', 'List of provides')
        form['instructions'] = 'Choose a xpath amongst them'
        form.add_reported("xpath")
        form.add_reported("tag")
        form.add_reported("label")
        form.add_reported("help")

        for provide in self.lfm.provide("//*"):
            tags = ""
            if provide['extra'].get('tags'):
                tags = ",".join(provide['extra']['tags'])

            form.add_item(OrderedDict({
                "xpath": provide['xpath'],
                "tag": tags,
                "label": provide['extra'].get('label', provide['name']),
                "help": provide['extra'].get('help', '')
            }))

        session['payload'] = form
        session['next'] = None  # self._handle_command_init_walk
        session['has_next'] = False
        session['id'] = str(uuid4())

        return session

    def _handle_command_build(self, iq, session):
        self.leave_muc_room()

        form = self['xep_0004'].makeForm('form', 'Specify a provide to build')
        form['instructions'] = 'specify'
        form.add_field(var="xpath")
        session['payload'] = form
        session['next'] = self._handle_command_init_build_next
        session['has_next'] = True
        session['id'] = str(uuid4())
        self.smart = None
        self.root_provide = None
        self.current_step = None

        self.join_muc_room(session)

        return session

    def _handle_command_init_build_next(self, payload, session):
        if self.smart is None:
            logger.debug("Step: Create root_provide")
            xpath = payload['values']['xpath']
            self.root_provide = BuildProvide(xpath)
            self.smart = smart_call(self.root_provide)

        if self.current_step == "manage":
            provide, step, args = self.smart.send(payload['values']['manage'])

        elif self.current_step == "lfm":
            provide, step, args = self.smart.send(payload['values']['host'])

        elif self.current_step == "specialize":
            provide, step, args = self.smart.send(payload['values']['xpath'])

        elif self.current_step == "multiplicity":
            provide, step, args = self.smart.send(payload['values']['multiplicity'].split(','))

        elif self.current_step == "validation":
            provide, step, args = self.smart.send(json.loads(payload['values']['validation']))

        elif self.current_step == "call":
            provide, step, args = self.smart.send(payload['values']['call'])

        else:
            provide, step, args = self.smart.next()

        if isinstance(args, SmartException):
            self.report_error(args.name, args.message, session['from'])
            self.smart.next()

        form = self['xep_0004'].makeForm('form', 'Build a provide')
        self.current_step = step

        logger.debug("Current step is now %s" % step)

        form['instructions'] = step
        form.add_field(var="provide",
                       ftype="fixed",
                       value=provide.xpath or provide.generic_xpath,
                       label=provide.extra.get('label', provide.name))

        form.add_field(var="tree_id",
                       ftype="fixed",
                       value=str(json.dumps(provide.tree_id)))

        form.add_field(var="host",
                       ftype="fixed",
                       value=str(json.dumps(provide.host) or ""))

        if step == 'manage':
            provide_label = provide.extra.get('label', provide.generic_xpath)
            label = provide_label[0].lower() + provide_label[1:]
            field = form.add_field(var="manage",
                                   ftype="input-single",
                                   label="Do you want to %s ?" % label)

        elif step == 'lfm':
            provide_label = provide.extra.get('label', provide.generic_xpath)
            label = provide_label[0].lower() + provide_label[1:]
            field = form.add_field(var="host",
                                   ftype="input-single",
                                   label="Where do you want to %s ?" % label,
                                   value=json.dumps(provide.host))

        elif step == 'specialize':
            field = form.add_field(var="specialize",
                                   ftype="list-single",
                                   label="Choose")
            for provide_match in provide.matches():
                field.add_option(label=str(provide_match['extra'].get('label', provide_match['name'])),
                                 value=str(provide_match['xpath']))

        elif step == 'multiplicity':
            provide_label = provide.extra.get('label', provide.xpath)
            label = provide_label[0].lower() + provide_label[1:]
            form.add_field(var="multiplicity",
                           ftype="input-single",
                           label="On which hosts do you want to %s ?" % label,
                           value="1")

        elif step == 'validation':
            for variable in provide.variables():
                value = json.dumps(variable.value_get_one())
                field = form.add_field(var=str(variable.xpath),
                                       label=str(variable.name),
                                       ftype="list-multi",
                                       options=[
                                           {"label": "value", "value": str(value)},
                                           {"label": "type", "value": str(variable.type)},
                                           {"label": "error", "value": str(getattr(variable, "error", ""))},
                                           {"label": "resolved_by", "value": str(getattr(variable._resolved_by, "xpath", ""))},
                                           {"label": "suggested_by", "value": str(getattr(variable._suggested_by, "xpath", ""))},
                                           {"label": "set_by", "value": str(getattr(variable._set_by, "xpath", ""))}],
                                       required=variable.required)
                for key, value in variable.extra.items():
                    field.add_option(label=str(key), value=str(value))

        elif step == 'call':
            form.add_field(var="call",
                           ftype="input-single",
                           value="1")

        session['payload'] = form
        session['next'] = self._handle_command_init_build_next
        session['has_next'] = True

        # If the root provide step is done, this is the last answer.
        if step == 'done' and provide == self.root_provide:
            session['next'] = None
            session['has_next'] = False

        return session


if __name__ == '__main__':

    prog = os.path.basename(sys.argv[0])

    parser = argparse.ArgumentParser(prog=prog)

    cli_base = armonic.frontends.utils.CliBase(parser)
    cli_local = armonic.frontends.utils.CliLocal(parser, disable_options=["--os-type", "--simulation"])
    cli_xmpp = armonic.frontends.utils.CliXMPP(parser)
    args = cli_base.parse_args()
    args = cli_local.parse_args()
    args = cli_xmpp.parse_args()

    lfm = Serialize(os_type=OsTypeAll())
    logging.getLogger('armonic').setLevel(cli_base.logging_level)

    # Use /master resource by default
    xmpp_client = XMPPMaster('%s/master' % args.jid,
                             cli_xmpp.password,
                             plugins=[('xep_0050',), ('xep_0045',)],
                             muc_domain=args.muc_domain,
                             lfm=lfm)
    if not args.host:
        xmpp_client.connect()
    else:
        xmpp_client.connect(address=(args.host, args.port))
    try:
        xmpp_client.process(block=True)
    except KeyboardInterrupt:
        logger.info("Disconnecting...")
        pass
