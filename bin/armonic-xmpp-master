#!/usr/bin/python

import sys
import logging
import argparse
from uuid import uuid4
import json
import os.path

from sleekxmpp import ClientXMPP
from sleekxmpp.thirdparty import OrderedDict

import armonic.common
from armonic.serialize import Serialize
from armonic.client.smart import Provide, smart_call
from armonic.utils import OsTypeAll
import armonic.client.utils
from armonic.client.sock import ClientSocket


class MUCHandler(logging.Handler):

    def __init__(self, client=None, *args, **kwargs):
        logging.Handler.__init__(self, *args, **kwargs)
        self.client = client

    def emit(self, record):
        if self.client.muc_room and record:
            self.client.send_message(mto=self.client.muc_room,
                                     mbody=record.msg,
                                     mtype='groupchat')
        return True


class BuildProvide(Provide):

    def on_manage(self, data):
        # FIXME: Strophejs doesn't send a false value
        if data is None:
            self.manage = False
        else:
            self.manage = True

    def on_lfm(self, host):
        self.host = str(host)
        self.lfm = ClientSocket(host=host)


class Master(ClientXMPP):

    def __init__(self, jid, password, muc_domain, lfm):
        ClientXMPP.__init__(self, jid, password)
        self.add_event_handler("session_start", self.session_start)
        self.lfm = lfm
        self.smart = None

        self.muc_nick = 'master'
        self.muc_domain = muc_domain
        self.muc_room = None

    def leave_muc_room(self):
        if self.muc_room:
            self['xep_0045'].leaveMUC(self.muc_room, self.muc_nick)
            self.muc_room = None

    def join_muc_room(self, session):
        self.muc_room = "%s@%s" % (session['id'], self.muc_domain)
        logger.info('Joining muc_room %s' % self.muc_room)
        self['xep_0045'].joinMUC(self.muc_room,
                                 self.muc_nick)

    def session_start(self, event):
        self.send_presence()
        self.get_roster()

        self['xep_0050'].add_command(node='provides',
                                     name='Get the list of provides',
                                     handler=self._handle_command_provides)
        self['xep_0050'].add_command(node='build',
                                     name='Build a provide',
                                     handler=self._handle_command_build)

    def _handle_command_provides(self, iq, session):
        self.leave_muc_room()

        form = self['xep_0004'].makeForm('form', 'List of provides')
        form['instructions'] = 'Choose a xpath amongst them'
        form.add_reported("xpath")
        form.add_reported("tag")
        form.add_reported("label")
        form.add_reported("help")

        for provide in self.lfm.provide("//*"):
            tags = ""
            if provide['extra'].get('tags'):
                tags = ",".join(provide['extra']['tags'])

            form.add_item(OrderedDict({
                "xpath": provide['xpath'],
                "tag": tags,
                "label": provide['extra'].get('label', provide['name']),
                "help": provide['extra'].get('help', '')
            }))

        session['payload'] = form
        session['next'] = None  # self._handle_command_init_walk
        session['has_next'] = False
        session['id'] = str(uuid4())

        return session

    def _handle_command_build(self, iq, session):
        self.leave_muc_room()

        form = self['xep_0004'].makeForm('form', 'Specify a provide to build')
        form['instructions'] = 'specify'
        form.add_field(var="xpath")
        session['payload'] = form
        session['next'] = self._handle_command_init_build_next
        session['has_next'] = True
        session['id'] = str(uuid4())
        self.smart = None
        self.root_provide = None
        self.current_step = None

        self.join_muc_room(session)

        return session

    def _handle_command_init_build_next(self, payload, session):
        if self.smart is None:
            logger.debug("Step: Create root_provide")
            xpath = payload['values']['xpath']
            self.root_provide = BuildProvide(xpath)
            self.smart = smart_call(self.root_provide)

        if self.current_step == "manage":
            provide, step, args = self.smart.send(payload['values']['manage'])

        elif self.current_step == "lfm":
            provide, step, args = self.smart.send(payload['values']['host'])

        elif self.current_step == "specialize":
            provide, step, args = self.smart.send(payload['values']['xpath'])

        elif self.current_step == "multiplicity":
            provide, step, args = self.smart.send(payload['values']['multiplicity'].split(','))

        elif self.current_step == "validation":
            provide, step, args = self.smart.send(json.loads(payload['values']['validation']))

        elif self.current_step == "call":
            provide, step, args = self.smart.send(payload['values']['call'])

        else:
            provide, step, args = self.smart.next()

        form = self['xep_0004'].makeForm('form', 'Build a provide')
        self.current_step = step

        logger.debug("Current step is now %s" % step)

        form['instructions'] = step
        form.add_field(var="provide",
                       ftype="fixed",
                       value=provide.xpath or provide.generic_xpath,
                       label=provide.extra.get('label', provide.name))

        form.add_field(var="tree_id",
                       ftype="fixed",
                       value=str(json.dumps(provide.tree_id)))

        form.add_field(var="host",
                       ftype="fixed",
                       value=str(json.dumps(provide.host) or ""))

        if step == 'manage':
            provide_label = provide.extra.get('label', provide.generic_xpath)
            label = provide_label[0].lower() + provide_label[1:]
            field = form.add_field(var="manage",
                                   ftype="input-single",
                                   label="Do you want to %s ?" % label)

        elif step == 'lfm':
            provide_label = provide.extra.get('label', provide.generic_xpath)
            label = provide_label[0].lower() + provide_label[1:]
            field = form.add_field(var="host",
                                   ftype="input-single",
                                   label="Where do you want to %s ?" % label,
                                   value=json.dumps(provide.host))

        elif step == 'specialize':
            field = form.add_field(var="specialize",
                                   ftype="list-single",
                                   label="Choose")
            for provide_match in provide.matches():
                field.add_option(label=str(provide_match['extra'].get('label', provide_match['name'])),
                                 value=str(provide_match['xpath']))

        elif step == 'multiplicity':
            provide_label = provide.extra.get('label', provide.xpath)
            label = provide_label[0].lower() + provide_label[1:]
            form.add_field(var="multiplicity",
                           ftype="input-single",
                           label="On which hosts do you want to %s ?" % label,
                           value="1")

        elif step == 'validation':
            for variable in provide.variables():
                value = json.dumps(variable.value_get_one())
                field = form.add_field(var=str(variable.xpath),
                                       label=str(variable.name),
                                       ftype="list-multi",
                                       options=[
                                           {"label": "value", "value": str(value)},
                                           {"label": "type", "value": str(variable.type)},
                                           {"label": "error", "value": str(getattr(variable, "error", ""))},
                                           {"label": "resolved_by", "value": str(getattr(variable._resolved_by, "xpath", ""))},
                                           {"label": "suggested_by", "value": str(getattr(variable._suggested_by, "xpath", ""))},
                                           {"label": "set_by", "value": str(getattr(variable._set_by, "xpath", ""))}],
                                       required=variable.required)
                for key, value in variable.extra.items():
                    field.add_option(label=str(key), value=str(value))

        elif step == 'call':
            form.add_field(var="call",
                           ftype="input-single",
                           value="1")

        session['payload'] = form
        session['next'] = self._handle_command_init_build_next
        session['has_next'] = True

        # If the root provide step is done, this is the last answer.
        if step == 'done' and provide == self.root_provide:
            session['next'] = None
            session['has_next'] = False

        return session


if __name__ == '__main__':

    prog = os.path.basename(sys.argv[0])

    parser = argparse.ArgumentParser(prog=prog)
    parser.add_argument('--host',
                        type=str,
                        default="im.aeolus.org",
                        help="XMPP server host")
    parser.add_argument('--muc-domain',
                        type=str,
                        default="logs.im.aeolus.org",
                        help="XMPP MUC domain")
    parser.add_argument('--port',
                        default=5222, type=int,
                        help="XMPP server port (default '%(default)s')")
    parser.add_argument('--jid', '-j',
                        default='master@im.aeolus.org', type=str,
                        help="Jid (default '%(default)s')")
    parser.add_argument('--password', '-p',
                        default='master', type=str,
                        help="Password (default '%(default)s')")
    parser.add_argument('--input-event-file', '-i',
                        default='-', type=argparse.FileType('r', 0),
                        help="Input file where events are read")

    cli = armonic.client.utils.Cli()
    cli.parse_args(parser)
    args = parser.parse_args()

    lfm = Serialize(os_type=OsTypeAll())

    logging.getLogger('sleekxmpp').setLevel(logging.WARNING)
    logging.getLogger('armonic').setLevel(cli.logging_level)

    # Use /master resource by default
    xmpp = Master('%s/master' % args.jid, args.password, args.muc_domain,
                  lfm)

    xmpp.register_plugin('xep_0030')  # Service Discovery
    xmpp.register_plugin('xep_0004')  # Data Forms
    xmpp.register_plugin('xep_0050')  # Adhoc Commands
    xmpp.register_plugin('xep_0199', {'keepalive': True, 'frequency': 15})
    xmpp.register_plugin('xep_0045')  # MUC

    logger = logging.getLogger()
    muc_handler = MUCHandler(xmpp)
    muc_handler.addFilter(logging.Filter('armonic'))
    logger.addHandler(muc_handler)

    xmpp.connect(address=(args.host, args.port))
    try:
        xmpp.process(block=True)
    except KeyboardInterrupt:
        logger.info("Disconnecting...")
        pass
