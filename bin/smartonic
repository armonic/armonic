#!/usr/bin/python
import logging
import argparse

import readline

from armonic.serialize import Serialize
from armonic.client.iter_smart import Provide, walk
from armonic.utils import OsTypeMBS


def user_input_confirm(msg, prefix=''):
    """Ask the user if he confirm the msg question.

    :rtype: True if user confirm, False if not"""
    answer = raw_input(msg)
    if answer == 'n':
        return False
    return True


def user_input_choose_amongst(choices, prefix=''):
    """Ask the user if he confirm the msg question.

    :rtype: True if user confirm, False if not"""
    while True:
        print "%sYou must choose a provide amongst:" % prefix
        for i, c in enumerate(choices) :
            print "  %s%d) %s" % (prefix, i, c)
        answer = raw_input("%sChoose a provide [0-%d]: " % (prefix, len(choices)-1))
        try:
            return choices[int(answer)]
        except Exception as e:
            print e
            print "%sInvalid choice. Do it again!" % (prefix)


def user_input_variable(variable_name, message, prefix="", prefill=""):
    """
    :param variable_name: The name of the variable that user must set
    :param message: A help message
    :rtype: {variable_name:value}
    """
    prompt = "%s%s\n%s%s = " % (prefix, message, prefix, variable_name)
    readline.set_startup_hook(lambda: readline.insert_text(prefill))
    try:
        return {variable_name:raw_input(prompt)}
    finally:
        readline.set_startup_hook()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog='armonic-iter-smart')
    parser.add_argument(dest="xpath", type=str, help='A provide Xpath')
    parser.add_argument('--verbose',"-v", action="store_true")
    parser.add_argument('--host', type=str, 
                        default=None,
                        help='Host where to call the provide')

    args = parser.parse_args()

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    if args.host is None:
        lfm = Serialize(os_type=OsTypeMBS())
        class MyProvide(Provide):
            @property
            def lfm(self):
                return lfm
            @property
            def manage(self):
                return True
            @property
            def call(self):
                return False


        root_provide = MyProvide(generic_xpath=args.xpath)
    else:
        from armonic.client.sock import ClientSocket
        lfm = ClientSocket(host=args.host)
        class MyProvide(Provide):
            pass
        root_provide = MyProvide(generic_xpath=args.xpath)
        root_provide.lfm = lfm
            
        

    generator = walk(root_provide)
    
    # Data sent to the generator
    data = None

    while True:
        try:
            if data is None:
                (provide, step, args) = generator.next()
            else: 
                (provide, step, args) = generator.send(data)
                data = None
        except StopIteration:
            break
        if provide.tree_id == None:
            print provide.generic_xpath
        print "%s [%s %s] " % (provide.generic_xpath.ljust(60+2*provide.depth), 
                               provide.step.ljust(16), provide.tree_id)

        if provide.step == "manage":
            data = user_input_confirm("Manage %s [Y/n]? " % provide.generic_xpath)

        elif provide.step == "lfm":
            msg = "Choose a location"
            if provide.has_requirer():
                prefill = provide.requirer.lfm._host
            else:
                prefill = ""
            host = user_input_variable(variable_name = "location", message = msg, prefill=prefill)
            data = ClientSocket(host=host['location'])
            
        elif provide.step == "specialize":
            data = user_input_choose_amongst(args, "")

        elif provide.step == "set_dependancies":
            pass

        elif provide.step == "multiplicity":
            require = args
            while True:
                answer = raw_input("How many time to call %s? " % require.provide_xpath)
                try:
                    answer = int(answer)
                    break
                except Exception as e:
                    print e
                    print "Invalid choice. Do it again!"
            data = answer

        elif provide.step == "call":
            data = user_input_confirm("Call %s [Y/n]?" % provide.generic_xpath)

