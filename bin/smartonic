#!/usr/bin/python

import sys
import logging
import argparse
import os.path

import readline
from itertools import repeat
import json

from armonic.serialize import Serialize
from armonic.client.smart import Provide, smart_call
from armonic.client.utils import read_variable, show_variable
import armonic.client.utils


logger = logging.getLogger()


def user_input_confirm(msg, prefix=''):
    """Ask the user if he confirm the msg question.

    :rtype: True if user confirm, False if not"""
    answer = raw_input(msg)
    if answer == 'n':
        return False
    return True


def user_input_choose_amongst(choices, prefix=''):
    """Ask the user if he confirm the msg question.

    :rtype: True if user confirm, False if not"""
    while True:
        print "%sYou must choose a provide amongst:" % prefix
        for i, c in enumerate(choices):
            print "%s  %d) %s" % (prefix, i, c['xpath'])
        answer = raw_input("%sChoose a provide [0-%d]: " % (prefix, len(choices) - 1))
        try:
            return choices[int(answer)]['xpath']
        except Exception as e:
            print e
            print "%sInvalid choice. Do it again!" % (prefix)


def user_input_variable(variable_name, message, prefix="", prefill=""):
    """
    :param variable_name: The name of the variable that user must set
    :param message: A help message
    :rtype: {variable_name:value}
    """
    prompt = "%s%s\n%s%s = " % (prefix, message, prefix, variable_name)
    data = None
    while True:
        readline.set_startup_hook(lambda: readline.insert_text(prefill))
        try:
            data = read_variable(raw_input(prompt))
            break
        except KeyboardInterrupt:
            raise
        except Exception as e:
            print "%sThe folowing error occurs:" % prefix
            print "%s  %s" % (prefix, e)
            continue
        finally:
            readline.set_startup_hook()
    return {variable_name: data}


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog=os.path.basename(sys.argv[0]))
    parser.add_argument(dest="xpath", type=str, help='A provide Xpath')
    parser.add_argument('--host', type=str,
                        default=None,
                        help='Host where to call the provide')
    parser.add_argument('--input', type=str, default=None,
                        help="Load values from file")
    parser.add_argument('--output', type=str, default=None,
                        help="Save values in file")

    parser.add_argument('-a', '--autofill', action='store_true', default=False,
                        help="Autofill variables with proposed values")

    parser.add_argument('--manage', action='store_true', default=False,
                        help="Manage all provide without confirmation")


    cli = armonic.client.utils.Cli()
    args = cli.parse_args(parser)

    dont_call = args.dont_call
    autofill = args.autofill
    manage = args.manage

    if cli.no_remote:
        import armonic.common
        armonic.common.SIMULATION = args.simulation

        lfm = Serialize(os_type=cli.os_type)

        class MyProvide(Provide):
            # @lfm.setter
            # def lfm(self, value):
            #     return lfm
            def do_lfm(self):
                self.lfm = lfm
                return False

            def on_manage(self, data):
                return True

            def do_call(self):
                if dont_call:
                    return False
                else:
                    return True

        root_provide = MyProvide(generic_xpath=args.xpath)
    else:
        from armonic.client.sock import ClientSocket

        # To have colorized agent log
        import sys
        import termcolor

        class ColorFormatter(logging.Formatter):
            def format(self, record):
                ret = logging.Formatter.format(self, record)
                return termcolor.colored(ret, 'blue')

        handler = logging.StreamHandler(sys.stdout)
        handler.setLevel(cli.logging_level)
        format = '%(levelname)5s %(ip)15s - %(message)s'
        handler.setFormatter(ColorFormatter(format))

        class MyProvide(Provide):
            def on_lfm(self, host):
                self.host = host
                self.lfm = ClientSocket(host=host, handlers=[handler])

            def do_call(self):
                if dont_call:
                    return False
                else:
                    return True

        root_provide = MyProvide(generic_xpath=args.xpath)
        if args.host is not None:
            lfm = ClientSocket(host=args.host, handlers=[handler])
            root_provide.lfm = lfm

    prefill = {}
    if args.input and os.path.exists(args.input):
        with open(args.input) as fp:
            prefill = json.load(fp)

    output_file = False
    if args.output:
        output_file = args.output

    generator = smart_call(root_provide, prefill)

    # Data sent to the generator
    data = None

    def indent(depth, msg=""):
        prefix = "".join(repeat("  ", depth))
        return prefix + msg

    while True:

        try:
            if data is None:
                (provide, step, args) = generator.next()
            else:
                (provide, step, args) = generator.send(data)
                data = None
        except StopIteration:
            break

        if provide is None and step is None:
            if output_file:
                with open(output_file, 'w') as fp:
                    json.dump(args, fp, indent=2)
                    logger.info("Deployment values written in %s" % output_file)
            break

        if provide.tree_id is None:
            pass
#        print "%s [%s %s] " % (provide.generic_xpath.ljust(60+2*provide.depth),
#                               provide.step.ljust(16), provide.tree_id)

        if provide.step == "manage":
            if manage:
                data = True
            else:
                data = user_input_confirm(
                    indent(provide.depth,
                           "Do you want to configure and call '%s' [Y/n]? " % provide.generic_xpath))

        elif provide.step == "lfm":
            msg = "You have to set a location:"
            if provide.host is not None:
                prefill = show_variable(provide.host)
            elif provide.has_requirer():
                prefill = show_variable(provide.requirer.lfm._host)
            else:
                prefill = ""
            host = user_input_variable(variable_name="location", message=msg, prefix=indent(provide.depth), prefill=prefill)
            data = host['location']

        elif provide.step == "specialize":
            data = user_input_choose_amongst(args, prefix=indent(provide.depth))

        elif provide.step == "validation":
            if provide.variables() != []:
                logger.info(indent(provide.depth, "Variables are:"))

                def xpathOrNone(var):
                    if var is not None:
                        return var.xpath
                    else:
                        return None

                for v in provide.variables():
                    logger.debug("\tXpath          : %s" % v.xpath)
                    logger.debug("\tValue          : %s" % v.value)
                    logger.debug("\tValueResolved  : %s" % v.value_resolved)
                    logger.debug("\tDefault        : %s" % v.default)
                    logger.debug("\tDefaultResolved: %s" % v.default_resolved)
                    logger.debug("\tResolvedBy     : %s" % xpathOrNone(v._resolved_by))
                    logger.debug("\tSetBy          : %s" % xpathOrNone(v._set_by))
                    logger.debug("\tSuggestedBy    : %s %s" % (xpathOrNone(v._suggested_by), v.value_get_one()))
                    logger.info(indent(provide.depth, "\t%s : %s [%s]" % (v.name.ljust(25), str(v.value_get_one()).ljust(25), v.xpath)))

                if provide.variables_scope() != []:
                    logger.info(indent(provide.depth, "Variables scope is:"))

                for v in provide.variables_scope():
                    logger.info(indent(provide.depth, "\t%s : %s [%s]" % (v.name.ljust(25), str(v.value_get_one()).ljust(25), v.xpath)))

                for v in provide.variables():
                    # We don't show to user variables belonging to provide_ret
                    if (v.value is None or v.error is not None) and v.belongs_provide_ret is False:
                        # The user has to manually fill the variable
                        if autofill is False or v.value_get_one() is None or v.error is not None:
                            message = "Fill the variable %s (suggested value '%s')" % (v.xpath, v.value_get_one())
                            if v.error:
                                message = "Variable %s=%s doesn't validate : %s" % (v.xpath, v.value, v.error)
                            ret = user_input_variable(variable_name=v.name,
                                                      prefix=indent(provide.depth),
                                                      message=message,
                                                      prefill=show_variable(v.value_get_one()))
                            v.value = ret[v.name]
                            if v.error:
                                break
                        # The value is auto filled
                        else:
                            v.value = v.value_get_one()
                        logger.info("Variable '%s' set with value '%s'" % (v.xpath, v.value))

                logger.debug("Serialized variables:")
                serialized = provide.variables_serialized()
                logger.debug("\t%s" % str(serialized[1]))
                for v in serialized[0]:
                    logger.debug("\t%s" % str(v))

                # send variables for validation
                data = serialized[0]

        elif provide.step == "multiplicity":
            require = args
            while True:
                answer = raw_input(indent(provide.depth, "How many time to call %s? " % require.skel.provide_xpath))
                try:
                    answer = int(answer)
                    break
                except Exception as e:
                    print e
                    print indent(provide.depth, "Invalid choice. Do it again!")
            data = answer

            adresses = []
            if require.skel.type == 'external':
                for i in range(0, data):
                    tmp_var = "host[%d]" % i
                    adresses.append(user_input_variable(variable_name=tmp_var,
                                                        message=indent(provide.depth, "What is adress of node %s? " % i))[tmp_var])
                data = adresses

        elif provide.step == "call":
            data = user_input_confirm(indent(provide.depth, "Call %s [Y/n]?" % provide.generic_xpath))
