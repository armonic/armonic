#!/usr/bin/python
import logging
import argparse

from armonic.serialize import Serialize
from armonic.client.iter_smart import Provide, walk
from armonic.utils import OsTypeMBS


def user_input_confirm(msg, prefix=''):
    """Ask the user if he confirm the msg question.

    :rtype: True if user confirm, False if not"""
    answer = raw_input(msg)
    if answer == 'n':
        return False
    return True


def user_input_choose_amongst(choices, prefix=''):
    """Ask the user if he confirm the msg question.

    :rtype: True if user confirm, False if not"""
    while True:
        print "%sYou must choose a provide amongst:" % prefix
        for i, c in enumerate(choices) :
            print "  %s%d) %s" % (prefix, i, c)
        answer = raw_input("%sChoose a provide [0-%d]: " % (prefix, len(choices)-1))
        try:
            return choices[int(answer)]
        except Exception as e:
            print e
            print "%sInvalid choice. Do it again!" % (prefix)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog='armonic-iter-smart')
    parser.add_argument(dest="xpath", type=str, help='A provide Xpath')
    parser.add_argument('--verbose',"-v", action="store_true")
    parser.add_argument('--host', type=str, 
                        default=None,
                        help='Host where to call the provide')

    args = parser.parse_args()

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    if args.host is None:
        lfm = Serialize(os_type=OsTypeMBS())
    else:
        from armonic.client.sock import ClientSocket
        lfm = ClientSocket(host=args.host)
    
    root_provide = Provide(generic_xpath=args.xpath, lfm=lfm)
    generator = walk(root_provide)
    
    # Data sent to the generator
    data = None


    while True:
        try:
            if data is None:
                (provide, step, args) = generator.next()
            else: 
                (provide, step, args) = generator.send(data)
                data = None
        except StopIteration:
            break
        if provide.tree_id == None:
            print provide.generic_xpath
        print "%s [%s %s] " % (provide.generic_xpath.ljust(60+2*provide.depth), provide.step.ljust(12), provide.tree_id)

        if provide.step == "manage":
            data = user_input_confirm("Manage %s [Y/n]? " % provide.generic_xpath)

        elif provide.step == "specialize":
            data = user_input_choose_amongst(args, "")

        elif provide.step == "set_dependancies":
            pass

        elif provide.step == "multiplicity":
            require = args
            while True:
                answer = raw_input("How many time to call %s? " % require.provide_xpath)
                try:
                    answer = int(answer)
                    break
                except Exception as e:
                    print e
                    print "Invalid choice. Do it again!"
            generator.send(answer)

        elif provide.step == "done":
            ret = user_input_confirm("Call %s [Y/n]?" % provide.generic_xpath)
            if ret:
                print "Configuration requires of %s" %provide.generic_xpath
