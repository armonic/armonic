#!/usr/bin/python
import logging
import argparse

import readline

from armonic.serialize import Serialize
from armonic.client.iter_smart import Provide, walk
from armonic.utils import OsTypeMBS

from pprint import pprint


def user_input_confirm(msg, prefix=''):
    """Ask the user if he confirm the msg question.

    :rtype: True if user confirm, False if not"""
    answer = raw_input(msg)
    if answer == 'n':
        return False
    return True


def user_input_choose_amongst(choices, prefix=''):
    """Ask the user if he confirm the msg question.

    :rtype: True if user confirm, False if not"""
    while True:
        print "%sYou must choose a provide amongst:" % prefix
        for i, c in enumerate(choices) :
            print "  %s%d) %s" % (prefix, i, c)
        answer = raw_input("%sChoose a provide [0-%d]: " % (prefix, len(choices)-1))
        try:
            return choices[int(answer)]
        except Exception as e:
            print e
            print "%sInvalid choice. Do it again!" % (prefix)


def user_input_variable(variable_name, message, prefix="", prefill=""):
    """
    :param variable_name: The name of the variable that user must set
    :param message: A help message
    :rtype: {variable_name:value}
    """
    prompt = "%s%s\n%s%s = " % (prefix, message, prefix, variable_name)
    readline.set_startup_hook(lambda: readline.insert_text(prefill))
    try:
        return {variable_name:raw_input(prompt)}
    finally:
        readline.set_startup_hook()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog='armonic-iter-smart')
    parser.add_argument(dest="xpath", type=str, help='A provide Xpath')
    parser.add_argument('--verbose',"-v", action="store_true")
    parser.add_argument('--host', type=str, 
                        default=None,
                        help='Host where to call the provide')

    args = parser.parse_args()

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    if args.host is None:
        lfm = Serialize(os_type=OsTypeMBS())
        class MyProvide(Provide):
            @property
            def lfm(self):
                return lfm
            @property
            def manage(self):
                return True
            @property
            def call(self):
                return False


        root_provide = MyProvide(generic_xpath=args.xpath)
    else:
        from armonic.client.sock import ClientSocket


        # To have colorized agent log
        import sys
        import termcolor
        class ColorFormatter(logging.Formatter):
            def format(self,record):
                ret = logging.Formatter.format(self, record)
                return termcolor.colored(ret, 'grey')
        handler = logging.StreamHandler(sys.stdout)
        format = '%(levelname)5s %(ip)15s - %(message)s'
        handler.setFormatter(ColorFormatter(format))


        lfm = ClientSocket(host=args.host, handlers=[handler])
        class MyProvide(Provide):
            def on_lfm(self, host):
                self.host = host
                self._lfm = ClientSocket(host=host)                
                
        root_provide = MyProvide(generic_xpath=args.xpath)
        root_provide.lfm = lfm
            
        

    generator = walk(root_provide)
    
    # Data sent to the generator
    data = None

    while True:
        try:
            if data is None:
                (provide, step, args) = generator.next()
            else: 
                (provide, step, args) = generator.send(data)
                data = None
        except StopIteration:
            break
        if provide.tree_id == None:
            pass
#        print "%s [%s %s] " % (provide.generic_xpath.ljust(60+2*provide.depth), 
#                               provide.step.ljust(16), provide.tree_id)

        if provide.step == "manage":
            data = user_input_confirm("Manage %s [Y/n]? " % provide.generic_xpath)

        elif provide.step == "lfm":
            msg = "Choose a location"
            if provide.has_requirer():
                prefill = provide.requirer.lfm._host
            else:
                prefill = ""
            host = user_input_variable(variable_name = "location", message = msg, prefill=prefill)
            data = host['location']
            
        elif provide.step == "specialize":
            data = user_input_choose_amongst(args, "")

        elif provide.step == "set_dependancies":
            pass

                
        elif provide.step == "validation":
            print
            print "Provide %s" % provide.generic_xpath
            print "Variable scope is:" 
            for (k, v) in provide._scope_variables.items():
                print "\t%s : %s [%s]" % (k.ljust(25), str(v.value).ljust(25), v.xpath)
            print

            print "Variables to fill are:"
            for v in provide.variables():
                print "\t%s : %s [%s]" % (v.name.ljust(25), str(v.value).ljust(25), v.xpath)
            print

            for v in provide.variables():
                if v.value is None:
                    if v.from_xpath is not None:
                        print v.from_xpath
                    ret = user_input_variable(variable_name=v.name, message="Fill it:")
                    v.value = ret[v.name]

            print "Variable to send"
            pprint(provide.get_variables())
            
            print
                    

        elif provide.step == "multiplicity":
            require = args
            while True:
                answer = raw_input("How many time to call %s? " % require.provide_xpath)
                try:
                    answer = int(answer)
                    break
                except Exception as e:
                    print e
                    print "Invalid choice. Do it again!"
            data = answer

        elif provide.step == "call":
            data = user_input_confirm("Call %s [Y/n]?" % provide.generic_xpath)

