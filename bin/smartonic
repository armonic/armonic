#!/usr/bin/python
import logging
import argparse

import readline
from itertools import repeat

from armonic.serialize import Serialize
from armonic.client.smart import Provide, smart_call
from armonic.client.utils import read_variable, show_variable
import armonic.client.utils
from armonic.utils import OsTypeMBS, OsTypeDebianWheezy, OsTypeAll


logger = logging.getLogger()


def user_input_confirm(msg, prefix=''):
    """Ask the user if he confirm the msg question.

    :rtype: True if user confirm, False if not"""
    answer = raw_input(msg)
    if answer == 'n':
        return False
    return True


def user_input_choose_amongst(choices, prefix=''):
    """Ask the user if he confirm the msg question.

    :rtype: True if user confirm, False if not"""
    while True:
        print "%sYou must choose a provide amongst:" % prefix
        for i, c in enumerate(choices) :
            print "- %s%d) %s" % (prefix, i, c['xpath'])
        answer = raw_input("%sChoose a provide [0-%d]: " % (prefix, len(choices)-1))
        try:
            return choices[int(answer)]['xpath']
        except Exception as e:
            print e
            print "%sInvalid choice. Do it again!" % (prefix)


def user_input_variable(variable_name, message, prefix="", prefill=""):
    """
    :param variable_name: The name of the variable that user must set
    :param message: A help message
    :rtype: {variable_name:value}
    """
    prompt = "%s%s\n%s%s = " % (prefix, message, prefix, variable_name)
    data = None
    while True:
        readline.set_startup_hook(lambda: readline.insert_text(prefill))
        try:
            data = read_variable(raw_input(prompt))
            break
        except KeyboardInterrupt:
            raise
        except Exception as e:
            print "%sThe folowing error occurs:" % prefix
            print "%s  %s" % (prefix, e)
            continue
        finally:
            readline.set_startup_hook()
    return {variable_name:data}
        


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog='armonic-iter-smart')
    parser.add_argument(dest="xpath", type=str, help='A provide Xpath')
    parser.add_argument('--host', type=str,
                        default=None,
                        help='Host where to call the provide')


    cli = armonic.client.utils.Cli()
    args = cli.parse_args(parser)

    if args.no_remote:
        import armonic.common
        armonic.common.SIMULATION = args.simulation
        dont_call = args.dont_call

        lfm = Serialize(os_type=cli.os_type)
        class MyProvide(Provide):
            # @lfm.setter
            # def lfm(self, value):
            #     return lfm
            def do_lfm(self):
                self.lfm = lfm
                return False

            def on_manage(self, data):
                return True
                
            def do_call(self):
                if dont_call:
                    return False
                else:
                    return True

        root_provide = MyProvide(generic_xpath=args.xpath)
    else:
        from armonic.client.sock import ClientSocket

        # To have colorized agent log
        import sys
        import termcolor
        class ColorFormatter(logging.Formatter):
            def format(self,record):
                ret = logging.Formatter.format(self, record)
                return termcolor.colored(ret, 'blue')
        handler = logging.StreamHandler(sys.stdout)
        handler.setLevel(cli.logging_level)
        format = '%(levelname)5s %(ip)15s - %(message)s'
        handler.setFormatter(ColorFormatter(format))

        class MyProvide(Provide):
            def on_lfm(self, host):
                self.host = host
                self.lfm = ClientSocket(host=host, handlers=[handler])

        root_provide = MyProvide(generic_xpath=args.xpath)
        if args.host is not None:
            lfm = ClientSocket(host=args.host, handlers=[handler])
            root_provide.lfm = lfm



    generator = smart_call(root_provide)

    # Data sent to the generator
    data = None

    def indent(depth, msg=""):
        prefix = "".join(repeat("  ", depth))
        return prefix+msg

    while True:
        try:
            if data is None:
                (provide, step, args) = generator.next()
            else:
                (provide, step, args) = generator.send(data)
                data = None
        except StopIteration:
            break
        if provide.tree_id == None:
            pass
#        print "%s [%s %s] " % (provide.generic_xpath.ljust(60+2*provide.depth),
#                               provide.step.ljust(16), provide.tree_id)

        if provide.step == "manage":
            data = user_input_confirm(indent(provide.depth,
                                             "Do you want to configure and call '%s' [Y/n]? " % provide.generic_xpath))

        elif provide.step == "lfm":
            msg = "You have to set a location:"
            if provide.host is not None:
                prefill = show_variable(provide.host)
            elif provide.has_requirer():
                prefill = show_variable(provide.requirer.lfm._host)
            else:
                prefill = ""
            host = user_input_variable(variable_name = "location", message = msg, prefix = indent(provide.depth), prefill=prefill)
            data = host['location']

        elif provide.step == "specialize":
            data = user_input_choose_amongst(args, prefix=indent(provide.depth))

        elif provide.step == "set_dependencies":
            pass


        elif provide.step == "validation":
            if provide.variables() != []:
                logger.info(indent(provide.depth, "Variables are:"))

                def xpathOrNone(var):
                    if var is not None:
                        return var.xpath
                    else: return None

                for v in provide.variables():
                    logger.debug("\tXpath:           %s" % v.xpath)
                    logger.debug("\tValue :          %s" % v.value)
                    logger.debug("\tValueResolved    %s" % v.value_resolved)
                    logger.debug("\tDefault:         %s" % v.default)
                    logger.debug("\tDefaultResolved: %s" % v.default_resolved)
                    logger.debug("\tResolvedBy     : %s" % xpathOrNone(v._resolved_by))
                    logger.debug("\tSetBy          : %s" % xpathOrNone(v._set_by))
                    logger.debug("\tSuggestedBy    : %s" % xpathOrNone(v._suggested_by))
                    logger.info(indent(provide.depth, "\t%s : %s [%s]" % (v.name.ljust(25), str(v.value_get_one()).ljust(25), v.xpath)))

                if provide.variables_scope() != []:
                    logger.info(indent(provide.depth, "Variables scope is:"))
                for v in provide.variables_scope():
                    logger.info(indent(provide.depth, "\t%s : %s [%s]" % (v.name.ljust(25), str(v.value_get_one()).ljust(25), v.xpath)))

                for v in provide.variables():
                    if v.value is None:
                        if v.from_xpath is not None:
                            print v.from_xpath
                        ret = user_input_variable(variable_name=v.name,
                                                  prefix=indent(provide.depth),
                                                  message="Fill using JSON format the variable %s" % v.xpath,
                                                  prefill=show_variable(v.value_get_one()))
                        v.value = ret[v.name]

                logger.debug("Serialized variables:")
                for v in provide.variables_serialized():
                    logger.debug("\t%s" % str(v))


        elif provide.step == "multiplicity":
            require = args
            while True:
                answer = raw_input(indent(provide.depth, "How many time to call %s? " % require.skel.provide_xpath))
                try:
                    answer = int(answer)
                    break
                except Exception as e:
                    print e
                    print indent(provide.depth, "Invalid choice. Do it again!")
            data = answer
            
            adresses = []
            if require.skel.type == 'external':
                for i in range(0,data):
                    tmp_var = "host[%d]" % i
                    adresses.append(user_input_variable(variable_name=tmp_var,
                                                         message=indent(provide.depth, "What is adress of node %s? " % i))[tmp_var])
                data = adresses

        elif provide.step == "call":
            data = user_input_confirm(indent(provide.depth, "Call %s [Y/n]?" % provide.generic_xpath))

