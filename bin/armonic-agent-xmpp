#!/usr/bin/python
"""
Socket agent.

All logger event are send through the socket.
The return of function call is :
{"return":value} | {"exception":value}.
'value' is "picklized".

Protocol:
1) send a struct ((int) msg_size_in_bytes , (bool) last_msg?)
2) send message

xmpp agent

add compte serveur ejabbert
ejabberdctl register armonictest localhost armonictest 

_____________

the command line options always override

eg . armonic-agent-xmpp -v --host localhost --port 5222  
       --jid user2@localhost --ressource user2 --password user2

"""
import logging
import urlparse
import argparse
import json
from armonic.serialize import Serialize
from armonic.serialize import MethodNotExposed
from armonic.persist import Persist
import armonic.common
from armonic.utils import OsTypeAll
from armonic.iq_xmpp_armonic import ActionProvider
import sleekxmpp
from sleekxmpp import ClientXMPP, Iq
from sleekxmpp.exceptions import XMPPError, IqError, IqTimeout
from sleekxmpp.xmlstream import register_stanza_plugin
from sleekxmpp.xmlstream.handler import Callback
from sleekxmpp.xmlstream.matcher import StanzaPath
import sys
from logging.handlers import RotatingFileHandler
import re

#from armonic.client.utils import Cli
import armonic.frontends.utils
PACKET_INFO_SIZE = 5

if sys.version_info < (3, 0):
    from sleekxmpp.util.misc_ops import setdefaultencoding
    setdefaultencoding('utf8')
else:
    raw_input = input


class ActionXmppProvider(ClientXMPP):
    """
    A simple SleekXMPP bot that receives a custom stanza
    from another client.
    """
    def __init__(self, jid, password, jid_master):
        sleekxmpp.ClientXMPP.__init__(self, jid, password)
        self.jid_master = jid_master

        self.add_event_handler("session_start", self.start)
        self.add_event_handler("failed_auth", self._handle_failed_auth)
        self.add_event_handler("session_end", 
                               lambda e : logger.info("Disconnecting..."))

        self.add_event_handler("register", self.register, threaded=True)

        # To handle LifecycleManager method calls
        self.registerHandler(
          Callback('Some custom iq',
                   StanzaPath('iq@type=set/action'),
                   self._handle_action))
        self.add_event_handler('custom_action',
                               self._handle_action_event,
                               threaded=True)
        register_stanza_plugin(Iq, ActionProvider)


    def _handle_failed_auth(self, event):
        logger.error("Authentification failed for '%s'" % self.jid)
        #self.disconnect()
        
    def start(self, event):
        logger.info("Connected")
        logger.debug("Sending presence...")
        self.send_presence()
        logger.info("Presence sent to '%s'" % self.jid_master)
        self.send_presence(pto=self.jid_master, ptype='subscribe',pstatus="agent armonic",pshow="chat")

    def _handle_action(self, iq):
        """
        Raise an event for the stanza so that it can be processed in its
        own thread without blocking the main stanza processing loop.
        """
        self.event('custom_action', iq)

    def parsejson(self, data):
        """ transform json en arg et karg """
        return json.loads(data)

    def _handle_action_event(self, iq):
        """
        Respond to the custom action event.
        Since one of the actions is to disconnect, this
        event handler needs to be run in threaded mode, by
        using `threaded=True` in the `add_event_handler` call.
        """
        param = iq['action']['param']
        method = iq['action']['method']
        reponse_error_to= iq['from']
        reponse_error_from=iq['to']
        logger.info("Executing method '%s' called by '%s'..." % (method, iq['from']))
        try:
            request = self.parsejson(param)
            ret = lfm._dispatch(method, *request['args'], **request['kwargs'])
            #logger.info("return %s" % ret)
            iq.reply()
            iq['action']['status'] = json.dumps(ret)
            iq.send()
        except MethodNotExposed as e:
            logger.info("method %s not supported : %s"% (method,e))
            logger.info("%s : Method failure"% (method))
            iq['action']['status'] = "error"
            iq.error()
            iq['error']['code'] = "424"
            iq['error']['text'] = e
            iq['error']['type'] = "error"
            iq['error']['condition'] = 'Method failure'
            iq['to'] =  reponse_error_to
            iq['from'] = reponse_error_from
            iq.send()


    def register(self, iq):
        """
            Fill out and submit a registration form.
            The form may be composed of basic registration fields, a data form,
            an out-of-band link, or any combination thereof. Data forms and OOB
            links can be checked for as so:
            if iq.match('iq/register/form'):
            # do stuff with data form
            # iq['register']['form']['fields']
            if iq.match('iq/register/oob'):
            # do stuff with OOB URL
            # iq['register']['oob']['url']
            To get the list of basic registration fields, you can use:
            iq['register']['fields']
        """
        logger.debug("Registration of '%s'..." % self.jid)
        resp = self.Iq()
        resp['type'] = 'set'
        resp['register']['username'] = self.boundjid.user
        resp['register']['password'] = self.password
        try:
            resp.send(now=True)
            logging.info("Account registered for '%s'" % self.jid)
        except IqError as e:
            logging.debug("Could not register account '%s'" % self.jid)
            logging.debug("\t%s" % e.iq['error']['text'])
        except IqTimeout:
            logging.error("No response from server.")
            self.disconnect()


def args_option(args_cli,args_xml_config, msg, default_val=None):
    if not args_cli and not args_xml_config:
        if default_val is None:
           logger.critical(msg)
           sys.exit(1)
        else:
           return  default_val
    else:
        if not args_cli:
            return args_xml_config
        else:
            return args_cli

if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog=__file__)

    parser.add_argument('--no-load-state', '-l', dest="no_load_state", action="store_true", default=False, help='Load Armonic agent state on start (default: %(default)s))')
    parser.add_argument('--no-save-state', '-s', dest="no_save_state", action="store_true", default=False, help='Save Armonic agent state on exit (default: %(default)s))')
    parser.add_argument('--state-path', dest="state_path", type=str, default="/tmp/armonic_%s%s_state", help='Armonic state files paths (default: %(default)s))')

    parser.add_argument('--host', '-H',
                        type=str,
                        required=True,
                        help="XMPP server host jabbert")
    parser.add_argument('--port', '-P',
                        type=int,
                        default=5222,
                        help="XMPP server port (default '%(default)s')")
    parser.add_argument('--jid', '-j',
                        required=True,
                        type=str,
                        help="Jid (default '%(default)s')")
    parser.add_argument('--jid-master',
                        type=str,
                        default="master@im.aeolus.org",
                        help="Jid of the master (default '%(default)s')")
    parser.add_argument('--ressource', '-r',
                        required=True,
                        type=str,
                        help="ressource (default '%(default)s')")
    parser.add_argument('--password', '-p',
                        type=str,
                        help="Password (default '%(default)s')")
    parser.add_argument('--verbose-xmpp',
                        action='store_true',
                        default=False,
                        help="Enable sleekxmpp logging")
    cli = armonic.frontends.utils.CliBase(parser)
    cli_local = armonic.frontends.utils.CliLocal(parser)

    args = cli.parse_args()
    args = cli_local.parse_args()

    logger = logging.getLogger()
    #logger.setLevel(cli.logging_level)

    formatter = logging.Formatter('%(asctime)s :: %(levelname)s :: %(message)s')
    file_handler = RotatingFileHandler("/tmp/armonic-agent-xmpp.log", 'a', 1000000, 1)
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    # We just enable sleekxmmp logs if DEBUG mode is set
    if args.verbose_xmpp:
        logging.getLogger("sleekxmpp").setLevel(cli.logging_level)
    else:
        logging.getLogger("sleekxmpp").setLevel(logging.ERROR)
        

    save_state = not args.no_save_state
    load_state = not args.no_load_state
    persist = Persist(load_state, save_state, args.state_path)
    lfm = Serialize(os_type=cli.os_type)

    xmpp = ActionXmppProvider(args.jid + "/" + args.ressource, args.password, args.jid_master)
    xmpp.register_plugin('xep_0199', {'keepalive': True, 'frequency':15})
    xmpp.register_plugin('xep_0030') # Service Discovery
    xmpp.register_plugin('xep_0004') # Data forms
    xmpp.register_plugin('xep_0066') # Out-of-band Data
    xmpp.register_plugin('xep_0077') # In-band Registration
    xmpp['xep_0077'].force_registration = True

    if xmpp.connect(address=(args.host, args.port)):
        logger.info("Connecting with account '%s'..." % (args.jid))
        xmpp.process(block=True)
    else:
        logger.info("Unable to connect.")
