#!/usr/bin/python
"""
Socket agent.

All logger event are send through the socket.
The return of function call is :
{"return":value} | {"exception":value}.
'value' is "picklized".

Protocol:
1) send a struct ((int) msg_size_in_bytes , (bool) last_msg?)
2) send message

xmpp agent

add compte serveur ejabbert
ejabberdctl register armonictest localhost armonictest 

_____________

the command line options always override

eg . armonic-agent-xmpp -v --host localhost --port 5222  --jid user2@localhost --ressource user2 --password user2

"""
import logging
import urlparse
import argparse
import json
from armonic.serialize import Serialize
from armonic.persist import Persist
import armonic.common
from armonic.utils import OsTypeAll
from armonic.iq_xmpp_armonic import ActionProvider
import sleekxmpp
from sleekxmpp import ClientXMPP, Iq
from sleekxmpp.exceptions import   XMPPError
from sleekxmpp.xmlstream import register_stanza_plugin
from sleekxmpp.xmlstream.handler import Callback
from sleekxmpp.xmlstream.matcher import StanzaPath
import sys
from logging.handlers import RotatingFileHandler
import re
from armonic.client.utils import Cli

PACKET_INFO_SIZE = 5

if sys.version_info < (3, 0):
    from sleekxmpp.util.misc_ops import setdefaultencoding
    setdefaultencoding('utf8')
else:
    raw_input = input


class ActionXmppProvider(ClientXMPP):
    """
    A simple SleekXMPP bot that receives a custom stanza
    from another client.
    """
    def __init__(self, jid, password):
        sleekxmpp.ClientXMPP.__init__(self, jid, password)
        self.name_master = "master"
        try:
            test = re.match("^([a-zA-Z0-9\.]{1,50})+\@([a-zA-Z0-9\.]{1,50})+\/([a-zA-Z0-9]{1,50})?$", jid)
            (node,domaine,ressource) = test.groups()
        except Exception :
            logger.error("error : host server xmpp : %s" % (jid))
            sys.exit(1)
        self.jid_master = self.name_master + "@" + domaine 
        self.add_event_handler("session_start", self.start)
        self.add_event_handler("changed_status", self.changed_status)
        self.add_event_handler("roster_update", self.show_roster)
        self.add_event_handler("got_online", self.now_online)
        self.add_event_handler("got_offline", self.now_offline)
        self.registerHandler(
          Callback('Some custom iq',
                   StanzaPath('iq@type=set/action'),
                   self._handle_action))
        self.add_event_handler('custom_action',
                               self._handle_action_event,
                               threaded=True)
        register_stanza_plugin(Iq, ActionProvider)

    def start(self, event):
        self.send_presence()
        self.send_presence(pto=self.jid_master, ptype='subscribe',pstatus="agent armonic",pshow="chat")
        self.get_roster(callback=self._handle_roster)
        
    def show_roster(self, event):
        """ stanza type
        <iq to="jfk@localhost/jfk" type="result" id="6002ddd0-1e08-4fe2-84ea-e22d60cf9265-3"><query xmlns="jabber:iq:roster" ver="16"><item ask="subscribe" jid="rt@localhost" name="zero" subscription="none" /><item jid="test@localhost" name="test" subscription="both" /><item ask="subscribe" jid="dede" subscription="none"><group>Contacts</group></item><item jid="master@localhost" subscription="both" /><item jid="dede@localhost" subscription="from" /></query></iq>
        """
        #print dir(event)
        logger.info("ROSTER VERSION %s" % event['roster']['ver'])
        roster = self.client_roster
        items = event['roster']['items']
        valid_subscriptions = ('to', 'from', 'both')#, 'none', 'remove'
        for jid, item in items.items():
            if item['subscription'] in valid_subscriptions:
                logger.info("subcription %s : %s " % (jid , item['subscription'])) 

    def changed_status(self, event):
        #<presence to="jfk@localhost" type="unavailable" from="master@localhost/home"><status>Disconnected: session closed</status></presence>
        #etat_client = json.dump("{'xa':'absent longue duree','chat':'pret a discuter','away','absent','dnd':'ne pas derranger')")
        logger.info("changed status: %s :[%s] %s " % (event['from'],event['status'], event['message']))
        #print "* %s(%s/%s) %s: %s" % (event['name'], event['jid'], event['resource'], event['type'],)
        
        #print event['jid']
        #print event['message']
        #print "eeeeee"
        
    def _handle_roster(self,iq):
        logger.debug("ROSTER VERSION %s" % iq['roster']['ver'])
        roster = self.client_roster
        items = iq['roster']['items']
        valid_subscriptions = ('to', 'from', 'both')#, 'none', 'remove'
        for jid, item in items.items():
            if item['subscription'] in valid_subscriptions:
                logger.info("subcription %s : %s " % (jid , item['subscription']))

    def _handle_action(self, iq):
        """
        Raise an event for the stanza so that it can be processed in its
        own thread without blocking the main stanza processing loop.
        """
        self.event('custom_action', iq)
        
    def now_online(self, event):
        print "online : %s %s [%s]" % (event['from'],event['type'],event['status'])
        #print "online"
        print event
        #print event['to']
        #print event['jid']
        #print "* %s(%s/%s) got online as %s: %s" % (event['name'], event['jid'],  , print print "online : %s" % 
        #print "gggggggggg"
        
    def now_offline(self, event):
        print "offline : %s %s [%s]" % (event['from'],event['type'],event['status'])


    def parsejson(self, data):
        """ transform json en arg et karg """
        return json.loads(data)

    def _handle_action_event(self, iq):
        """
        Respond to the custom action event.
        Since one of the actions is to disconnect, this
        event handler needs to be run in threaded mode, by
        using `threaded=True` in the `add_event_handler` call.
        """
        param = iq['action']['param']
        method = iq['action']['method']
        reponse_error_to= iq['from']
        reponse_error_from=iq['to']
        try:
            request = self.parsejson(param)
            ret = lfm._dispatch(method, *request['args'], **request['kwargs'])
            #logger.info("return %s" % ret)
            iq.reply()
            iq['action']['status'] = json.dumps(ret)
            iq.send()
        except Exception as e:
            logger.info("method %s not supported : %s"% (method,e))
            logger.info("%s : Method failure"% (method))
            iq['action']['status'] = "error"
            iq.error()
            iq['error']['code'] = "424"
            iq['error']['text'] = e
            iq['error']['type'] = "error"
            iq['error']['condition'] = 'Method failure'
            iq['to'] =  reponse_error_to
            iq['from'] = reponse_error_from
            iq.send()

def args_option(args_cli,args_xml_config, msg, default_val=None):
    if not args_cli and not args_xml_config:
        if default_val is None:
           logger.critical(msg)
           sys.exit(1)
        else:
           return  default_val
    else:
        if not args_cli:
            return args_xml_config
        else:
            return args_cli

if __name__ == "__main__":
    cli = Cli()
    parser = argparse.ArgumentParser(prog=__file__)

    parser.add_argument('--no-load-state', '-l', dest="no_load_state", action="store_true", default=False, help='Load Armonic agent state on start (default: %(default)s))')
    parser.add_argument('--no-save-state', '-s', dest="no_save_state", action="store_true", default=False, help='Save Armonic agent state on exit (default: %(default)s))')
    parser.add_argument('--state-path', dest="state_path", type=str, default="/tmp/armonic_%s%s_state", help='Armonic state files paths (default: %(default)s))')

    parser.add_argument('--host', '-H',
                        type=str,
                        required=True,
                        help="XMPP server host jabbert")
    parser.add_argument('--port', '-P',
                        required=True,
                        type=int,
                        help="XMPP server port (default '%(default)s')")
    parser.add_argument('--jid', '-j',
                        required=True,
                        type=str,
                        help="Jid (default '%(default)s')")
    parser.add_argument('--ressource', '-r',
                        required=True,
                        type=str,
                        help="ressource (default '%(default)s')")
    parser.add_argument('--password', '-p',
                        type=str,
                        help="Password (default '%(default)s')")

    args = cli.parse_args(parser)

    logger = logging.getLogger()
    logger.setLevel(cli.logging_level)

    formatter = logging.Formatter('%(asctime)s :: %(levelname)s :: %(message)s')
    file_handler = RotatingFileHandler("/tmp/armonic-agent-xmpp.log", 'a', 1000000, 1)
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)
    # redirect vers console
    steam_handler = logging.StreamHandler()
    steam_handler.setLevel(logging.DEBUG)
    logger.addHandler(steam_handler)
    
    save_state = not args.no_save_state
    load_state = not args.no_load_state
    persist = Persist(load_state, save_state, args.state_path)
    lfm = Serialize(os_type=cli.os_type)
    xmpp = ActionXmppProvider(args.jid + "/" + args.ressource, args.password)
    xmpp.register_plugin('xep_0030') # Service Discovery
    xmpp.register_plugin('xep_0004') # Data Forms
    xmpp.register_plugin('xep_0050') # Adhoc Commands
    xmpp.register_plugin('xep_0199', {'keepalive': True, 'frequency':15})
    if xmpp.connect(address=(args.host, args.port)):
        logger.info("connection %s:%s " % (args.host,args.port))
        xmpp.process(block=True)
        logger.info("end agent")
    else:
        logger.info("Unable to connect.")
