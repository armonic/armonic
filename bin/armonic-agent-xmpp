#!/usr/bin/python
"""
Socket agent.

All logger event are send through the socket.
The return of function call is :
{"return":value} | {"exception":value}.
'value' is "picklized".

Protocol:
1) send a struct ((int) msg_size_in_bytes , (bool) last_msg?)
2) send message

xmpp agent

add compte serveur ejabbert
ejabberdctl register armonictest localhost armonictest

_____________

the command line options always override

eg . armonic-agent-xmpp --host localhost --jid user2@localhost
        --jid-master master@localhost --password user2

"""
import logging
import argparse
import json
from armonic.serialize import Serialize
from armonic.serialize import MethodNotExposed
from armonic.persist import Persist
import armonic.common
from armonic.iq_xmpp_armonic import ActionProvider
import sleekxmpp
from sleekxmpp import ClientXMPP, Iq
from sleekxmpp.exceptions import IqError, IqTimeout
from sleekxmpp.xmlstream import register_stanza_plugin
from sleekxmpp.xmlstream.handler import Callback
from sleekxmpp.xmlstream.matcher import StanzaPath
import sys
from logging.handlers import RotatingFileHandler
import armonic.frontends.utils

if sys.version_info < (3, 0):
    from sleekxmpp.util.misc_ops import setdefaultencoding
    setdefaultencoding('utf8')
else:
    raw_input = input


class MalformedJID(Exception):
    pass


class ActionXmppProvider(ClientXMPP):
    """
    A simple SleekXMPP bot that receives a custom stanza
    from another client.
    """
    def __init__(self, jid, password, jid_master):
        sleekxmpp.ClientXMPP.__init__(self, jid + "/agent", password)
        if self.resource != "agent":
            msg = "The agent JID must not contain ressource"
            logger.critical(msg)
            raise MalformedJID(msg)
        logger.info("Connecting with account '%s'..." % (self.fulljid))

        self.jid_master = jid_master
        self.add_event_handler("presence_available",
                               self._handle_presence_available)
        self.add_event_handler("session_start", self.start)
        self.add_event_handler("stream_error", self._handle_stream_error)
        self.add_event_handler("failed_auth", self._handle_failed_auth)
        self.add_event_handler("session_end",
                               lambda e: logger.info("Disconnecting..."))

        self.add_event_handler("register", self.register, threaded=True)

        # To handle LifecycleManager method calls
        self.registerHandler(
            Callback('Some custom iq',
                     StanzaPath('iq@type=set/action'),
                     self._handle_action))
        self.add_event_handler('call_method',
                               self._handle_call_method,
                               threaded=True)
        register_stanza_plugin(Iq, ActionProvider)

    def _handle_stream_error(self, event):
        if event['condition'] == "conflict":
            logger.warning("This jid is already in use... Reconnecting...")

    def _handle_presence_available(self, event):
        pass

    def _handle_failed_auth(self, event):
        logger.error("Authentification failed for '%s'" % self.jid)
        self.disconnect()

    def start(self, event):
        logger.info("Connected")
        logger.debug("Sending presence...")
        self.send_presence()
        logger.info("Presence sent to '%s'" % self.jid_master)
        self.send_presence(pto=self.jid_master, ptype='subscribe',
                           pstatus="agent armonic", pshow="chat")

    def _handle_action(self, iq):
        """
        Raise an event for the stanza so that it can be processed in its
        own thread without blocking the main stanza processing loop.
        """
        self.event('call_method', iq)

    def parsejson(self, data):
        """ transform json en arg et karg """
        return json.loads(data)

    def _handle_call_method(self, iq):
        """
        Respond to the custom action event.
        Since one of the actions is to disconnect, this
        event handler needs to be run in threaded mode, by
        using `threaded=True` in the `add_event_handler` call.
        """
        param = iq['action']['param']
        method = iq['action']['method']
        reponse_error_to = iq['from']
        reponse_error_from = iq['to']
        logger.info("Executing method '%s' called by '%s'..." % (
            method, iq['from']))
        try:
            request = self.parsejson(param)
            ret = lfm._dispatch(method, *request['args'], **request['kwargs'])
            iq.reply()
            iq['action']['status'] = json.dumps(ret)
            iq.send()
        except MethodNotExposed as e:
            logger.info("method %s not supported : %s" % (method, e))
            iq['action']['status'] = "error"
            iq.error()
            iq['error']['code'] = "424"
            iq['error']['text'] = e
            iq['error']['type'] = "error"
            iq['error']['condition'] = 'Method failure'
            iq['to'] = reponse_error_to
            iq['from'] = reponse_error_from
            iq.send()
        except IqError as e:
            logger.error("call method returned an error: %s" % (
                e.iq['error']['condition']))

    def register(self, iq):
        """
            Fill out and submit a registration form.
            The form may be composed of basic registration fields, a data form,
            an out-of-band link, or any combination thereof. Data forms and OOB
            links can be checked for as so:
            if iq.match('iq/register/form'):
            # do stuff with data form
            # iq['register']['form']['fields']
            if iq.match('iq/register/oob'):
            # do stuff with OOB URL
            # iq['register']['oob']['url']
            To get the list of basic registration fields, you can use:
            iq['register']['fields']
        """
        logger.debug("Registration of '%s'..." % self.jid)
        resp = self.Iq()
        resp['type'] = 'set'
        resp['register']['username'] = self.boundjid.user
        resp['register']['password'] = self.password
        try:
            resp.send(now=True)
            logging.info("Account registered for '%s'" % self.jid)
        except IqError as e:
            logging.debug("Could not register account '%s'" % self.jid)
            logging.debug("\t%s" % e.iq['error']['text'])
        except IqTimeout:
            logging.error("No response from server.")
            self.disconnect()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog=__file__)

    parser.add_argument('--no-load-state', '-l', dest="no_load_state",
                        action="store_true", default=False,
                        help='Load Armonic agent state on start (default: %(default)s))')
    parser.add_argument('--no-save-state', '-s', dest="no_save_state",
                        action="store_true", default=False,
                        help='Save Armonic agent state on exit (default: %(default)s))')
    parser.add_argument('--state-path', dest="state_path", type=str,
                        default="/tmp/armonic_%s%s_state",
                        help='Armonic state files paths (default: %(default)s))')
    parser.add_argument('--host', '-H', type=str,
                        help="XMPP server IP (if DNS is not set correctly)")
    parser.add_argument('--port', '-P',
                        type=int,
                        default=5222,
                        help="XMPP server port (default '%(default)s')")
    parser.add_argument('--jid', '-j',
                        required=True,
                        type=str,
                        help="Agent JID <username@fqdn>")
    parser.add_argument('--jid-master', type=str,
                        default="master@im.aeolus.org",
                        help="Jid of the master (default '%(default)s')")
    parser.add_argument('--password', '-p', type=str,
                        help="Password (default '%(default)s')")
    parser.add_argument('--verbose-xmpp', action='store_true', default=False,
                        help="Enable sleekxmpp logging")

    cli = armonic.frontends.utils.CliBase(parser)
    cli_local = armonic.frontends.utils.CliLocal(parser)

    args = cli.parse_args()
    args = cli_local.parse_args()

    logger = logging.getLogger()

    formatter = logging.Formatter(
        '%(asctime)s :: %(levelname)s :: %(message)s')
    file_handler = RotatingFileHandler("/tmp/armonic-agent-xmpp.log",
                                       'a',
                                       1000000, 1)
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    # We just enable sleekxmmp logs if DEBUG mode is set
    if args.verbose_xmpp:
        logging.getLogger("sleekxmpp").setLevel(cli.logging_level)
    else:
        logging.getLogger("sleekxmpp").setLevel(logging.ERROR)
    save_state = not args.no_save_state
    load_state = not args.no_load_state
    persist = Persist(load_state, save_state, args.state_path)
    lfm = Serialize(os_type=cli.os_type)

    try:
        xmpp = ActionXmppProvider(args.jid, args.password, args.jid_master)
    except MalformedJID:
        sys.exit(1)

    xmpp.register_plugin('xep_0199', {'keepalive': True, 'frequency': 15})
    xmpp.register_plugin('xep_0030')  # Service Discovery
    xmpp.register_plugin('xep_0004')  # Data forms
    xmpp.register_plugin('xep_0066')  # Out-of-band Data
    xmpp.register_plugin('xep_0077')  # In-band Registration
    xmpp['xep_0077'].force_registration = True

    if xmpp.connect(address=(args.host, args.port)):
        xmpp.process(block=True)
    else:
        logger.info("Unable to connect.")

