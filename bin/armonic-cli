#!/usr/bin/python
"""This is a client implementation module.

Actions needed to control agent:
- load a module
- get information about this module
"""

import argparse
import pprint
from prettytable import PrettyTable
import argcomplete
import json

from armonic.client.sock import ClientSocket
import armonic.client.utils

import os

def read_string(string):
    try:
        return int(string)
    except ValueError:
        return string

def reqList(args):
    """take a list of "args:value" strings and return a dict"""
    acc={}
    for a in args:
        s=a.split(":")
        acc.update({s[0]:read_string(s[1])})
    return acc


def parseArgs(args):
    """take a list of "args:value" strings and return a dict"""
    if args is None:
        return []
        
    # print args
    acc = {}
    # Take 
    # [[req1, v1:x , v2:x], [req2, ...]]
    # Transform to
    # {req1:[[v1:x, v2:x], [v2:x], ...], req2:[...]}
    for a in args:
        if a[0] in acc:
            acc[a[0]].append(a[1:])
        else: acc.update({a[0]:[a[1:]]})
    ret = acc
    # print ret
    
    # Take
    # {req1:[[v1:x, v2:x], [v2:x], ...], req2:[...]}
    # Transform to
    # {req1/v1 : {0:x}, req1/v2 : {1:x}, ...}
    acc = {}
    for req, variables in ret.items():
        for i in range(0,len(variables)):
            for k,v in reqList(variables[i]).items():
                key = req+"/"+k
                if key in ret:
                    acc[key].update({i:v})
                else:
                    acc[key] = {i:v}
    ret = acc
    # print ret
    
    # Take
    # {req1/v1 : {0:x}, req1/v2 : {1:x}, ...}
    # Transform to
    # [(req1/v1 : {0:x}), (req1/v2 : {1:x}), ...]
    # Moreover, it adds // if needed
    acc = []
    for k, v in ret.items():
        if k.startswith("/"):
            xpath = k
        else :
            xpath = "//"+k
        acc.append((xpath, v))
    ret = acc
    # print ret

    ret = (ret, {'source': None, 'uuid': None})
    return ret


def provide_to_table(provide):
    pprint.pprint(provide)
    for r in provide['requires']:
        print "  Require:    ", "%s type:%s" % (r['name'].ljust(15), r['type'].ljust(15))
        if r['type'] == 'simple':
            for a in r['variables_skel']:
                print "    Variable: ", "%s type:%s default:%s" % (a['name'].ljust(15),a['type'].ljust(8),a['default'])
        else:
            for a in r['provide_args']:
                print "    Variable (args)  : ", "%s type:%s default:%s" % (a['name'].ljust(15),a['type'].ljust(8),a['default'])
            for a in r['provide_ret']:
                print "    Variable (return): ", "%s type:%s default:%s" % (a['name'].ljust(15),a['type'].ljust(8),a['default'])


def state_to_table(state):
    x = PrettyTable(["Property","Value"])
    x.align = "l"
    x.add_row(["Name",state['name']])
    x.add_row(["Xpath",state['xpath']])
    x.add_row(["Supported OS","\n".join(map(str,state['supported_os_type']))])
    x.add_row(["Provides","\n".join([p['name'] for p in state['provides']])])
    x.add_row(["Enter Requires","\n".join([p['name'] for p in state['provide_enter']['requires']])])
    print x

def dict_to_table(dct):
    x = PrettyTable(["Property","Value"])
    x.align = "l"
    for k, v in dct.items():
        x.add_row([k,v])
    print x

def cmd_status(args):
    dict_to_table(client.info())

def cmd_lifecycle(args):
    if args.long_description:
        for m in client.lifecycle(args.xpath, long_description=True):
            dict_to_table(m)
    else:
        for m in client.lifecycle(args.xpath):
            print m

def cmd_xpath(args):
    if args.uri:
        pprint.pprint(client.call('uri', args.xpath))
    else:
        for r in client.call('xpath', args.xpath):
            print r

def cmd_state(args):
    if args.long_description:
        for r in client.call('state', xpath=args.xpath, doc=True):
            state_to_table(r)

    elif args.requires_list:
        ret=client.call('state_goto_requires', args.xpath)
        for r in ret['requires']:
            print r['xpath']
            provide_to_table(r)
    elif args.path:
        pprint.pprint(client.call('state_goto_path', args.xpath))

    else:
        for s in client.call('state', xpath=args.xpath, doc=False):
            print s

def cmd_state_current(args):
    for r in client.call('state_current', args.xpath):
        dict_to_table(r)

def cmd_state_goto(args):
    pprint.pprint(client.call('state_goto', args.xpath, parseArgs(args.require)))

def cmd_provide(args):
    if args.path:
        ret = client.call('provide_call_path', args.xpath)
        for r in ret:
            print
            print r['xpath']
            if r['paths'] == []:
                print "  can not be reached."
            for i, p in enumerate(r['paths']):
                print "path %i" % i
                for a in p:
                    print "  ", "%5s " % a[1], a[0]
        return
    else:
        ret=client.call('provide', args.xpath)
        for provide in ret:
            if args.all:
                print
                print provide['xpath']
                req=client.call('provide_call_requires', provide_xpath_uri=provide['xpath'])
                for p in req:
                    print "Need: ", p['xpath']
                    if args.long_description:
                        provide_to_table(p)
            else:
                print provide['xpath']
                if args.long_description:
                    provide_to_table(provide)


def cmd_provide_call(args):
    if args.check:
        ret = client.call('provide_call_validate', args.xpath, parseArgs(args.require))
        if ret['errors'] is False:
            print "Requires are valid."
        else:
            pprint.pprint(armonic.client.utils.require_validation_error(ret))
    else:
        pprint.pprint(client.call('provide_call', args.xpath, parseArgs(args.require)))

def cmd_plot(args):
    if args.T == 'dot':
        print client.call('to_dot', args.module, reachable = args.reachable)
    elif args.T == 'json':
            print json.dumps(client.call('to_primitive', args.module, reachable = args.reachable))
    elif args.T == 'json-human':
            pprint.pprint(client.call('to_primitive', args.module, reachable = args.reachable))
    elif args.T == 'automaton':
        raise NotImplementedError
    elif args.T == 'xml':
        print(client.call('to_xml', args.module))


parser = argparse.ArgumentParser(
    prog='armonic-client',
    description=("A simple client to contact a Armonic agent. "
                 "It is mainly used to get informations "
                 "but can also do some simple actions."))
parser.add_argument('--port','-P', type=int, default=8000,help='Mss agent port (default: %(default)s)')
parser.add_argument('--host','-H', type=str, default=os.environ.get('ARMONIC_AGENT_HOST', "localhost")
                    ,help="Armonic agent host (default: '%(default)s'). Agent host can also be specified with env variable 'ARMONIC_AGENT_HOST'")
parser.add_argument('--no-remote', action='store_true', default=False,  help="Directly use Armonic module.")
parser.add_argument('--version',"-V", action='version', version='%(prog)s ' + "0.1")
parser.add_argument('--verbose',"-v", type=int,default=20,help="From 10 (DEBUG) to 50 (ERROR). Default is %(default)s")
subparsers = parser.add_subparsers(help='<subcommand>')

parser_status = subparsers.add_parser('status', help='Show status of agent.')
parser_status.set_defaults(func=cmd_status)

parser_lifecycle = subparsers.add_parser('lifecycle', help='List lifecycles.')
parser_lifecycle.add_argument("xpath" , type=str,
                          default="//*[@ressource='lifecycle']", nargs="?",
                          help="A xpath. Default is '%(default)s' which matches all lifecycles.")
parser_lifecycle.add_argument('--long-description','-l',action='store_true',help="Show long description.")
parser_lifecycle.set_defaults(func=cmd_lifecycle)

parser_xpath = subparsers.add_parser('xpath', help='Get xpath')
parser_xpath.add_argument('xpath' , type=str, help='an xpath')
parser_xpath.add_argument('--uri','-u',action='store_true',help="Get uri associated to ressources that match the xpath.")
parser_xpath.set_defaults(func=cmd_xpath)

parser_state = subparsers.add_parser('state', help='List states.')
parser_state.add_argument("xpath" , type=str,
                          default="//*[@ressource='state']", nargs="?",
                          help="A xpath. Default is '%(default)s' which matches all states.")
parser_state.add_argument('--long-description','-l',action='store_true',help="Show long description.")
parser_state.add_argument('--path','-p',action='store_true',help="Show state path to go to these states.")
parser_state.add_argument('--requires-list','-r',action='store_true',help="List Requires to go to these states.")

parser_state.set_defaults(func=cmd_state)

parser_state_current = subparsers.add_parser('state-current', help='Show current state of a module.')
parser_state_current.add_argument('xpath' , type=str, help='a xpath that correspond to lifecycles.')
parser_state_current.set_defaults(func=cmd_state_current)

parser_state_goto = subparsers.add_parser('state-goto', help='Go to a state of a module.')
parser_state_goto.add_argument('xpath' , type=str, help='a xpath that correspond to a unique state.')
parser_state_goto.add_argument('-R',dest="require" , type=str,  nargs="*", action='append' , help="specify requires. Format is 'require_name value1:value value2:value'.")
parser_state_goto.set_defaults(func=cmd_state_goto)


parser_provide = subparsers.add_parser('provide', help='List provides.')
parser_provide.add_argument('xpath' , type=str, help='a xpath')
parser_provide.add_argument('--long-description','-l',action='store_true',help="Show long description")
parser_provide.add_argument('--path','-p',action='store_true',help="Show the path of state to call the provides")
parser_provide.add_argument('--all','-a',action='store_true',help="Show all provides required to call the provide")

parser_provide.set_defaults(func=cmd_provide)

parser_provide_call = subparsers.add_parser('provide-call', help='Call a provide.')
parser_provide_call.add_argument('xpath' , type=str, help='a xpath')
parser_provide_call.add_argument('--check','-c',action='store_true',help="Check if requires are valid")
parser_provide_call.add_argument('-R',dest="require" , type=str,  nargs="*", action='append', help="specify requires. Format is 'require_name value1:value value2:value'")
parser_provide_call.set_defaults(func=cmd_provide_call)

parser_plot = subparsers.add_parser('plot', help='Plot a lifecycle')
parser_plot.add_argument('module' , type=str, nargs='?', help='a module')
parser_plot.add_argument('--reachable','-r',action='store_true',help="Only reachable states from current state")
parser_plot.add_argument('-T', choices=['dot','json','json-human','automaton','xml'],help="print path to call this provide. For xml format, you can pipe armonic stdout to xmllint --format - to have a indented output ('client.py plot -T xml | xmllint --format -').")
parser_plot.set_defaults(func=cmd_plot)


argcomplete.autocomplete(parser)
args = parser.parse_args()

if args.no_remote is False:
    from armonic.client.sock import ClientSocket
    import logging
#    format = '%(asctime)s|%(levelname)6s - %(message)s'
    format = '%(asctime)s|%(levelname)6s - %(ip)s/%(xpath)s - %(message)s'
    sh = logging.StreamHandler()
    sh.setLevel(args.verbose)
    sh.setFormatter(logging.Formatter(format))
    client = ClientSocket(args.host, args.port)
    client.add_logging_handler(sh)
else:
    import armonic.serialize
    import armonic.common
    armonic.common.load_lifecycles()
    client = armonic.serialize.Serialize()

args.func(args)
